// This file is auto-generated by @hey-api/openapi-ts

export type GetAppJwksResponse = {
    /**
     * The value of the "keys" parameter is an array of JWK values. The order of keys has no
     * meaning.
     */
    keys: Array<JsonWebKey>;
};

/**
 * Standard Json Web Key specification following https://www.rfc-editor.org/rfc/rfc7517 and
 * https://www.rfc-editor.org/rfc/rfc7518.html.
 */
export type JsonWebKey = {
    /**
     * The "alg" (algorithm) parameter identifies the algorithm intended for
     * use with the key.
     * See https://www.rfc-editor.org/rfc/rfc7517#section-4
     */
    alg?: string;
    /**
     * The "kid" (key ID) parameter is used to match a specific key.  This
     * is used, for instance, to choose among a set of keys within a JWK Set
     * during key rollover. When "kid" values are used within a JWK Set,
     * different keys within the JWK Set SHOULD use distinct "kid" values.
     * The "kid" value is a case-sensitive string.
     * See https://www.rfc-editor.org/rfc/rfc7517#section-4
     */
    kid: string;
    /**
     * The "kty" (key type) parameter identifies the cryptographic algorithm
     * family used with the key, such as "RSA" or "EC". The "kty" value is a
     * case-sensitive string. At the moment, only "RSA" is supported.
     * See https://www.rfc-editor.org/rfc/rfc7517#section-4
     */
    kty: string;
    /**
     * The "n" (modulus) parameter contains the modulus value for the RSA
     * public key.  It is represented as a Base64urlUInt-encoded value.
     * See https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3
     */
    n: string;
    /**
     * The "e" (exponent) parameter contains the exponent value for the RSA
     * public key.  It is represented as a Base64urlUInt-encoded value.
     * See https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3
     */
    e: string;
    /**
     * The "use" (public key use) parameter identifies the intended use of
     * the public key. The "use" parameter is employed to indicate whether
     * a public key is used for encrypting data or verifying the signature
     * on data. Values are commonly "sig" (signature) or "enc" (encryption).
     * See https://www.rfc-editor.org/rfc/rfc7517#section-4
     */
    use?: string;
};

export type GetAssetResponse = {
    asset: Asset;
};

/**
 * @deprecated
 */
export type UploadAssetResponse = {
    asset: Asset;
};

export type UpdateAssetRequest = {
    /**
     * The name of the asset. This is shown in the Canva UI.
     * When this field is undefined, nothing is updated.
     * Maximum length 50 characters.
     */
    name?: string;
    /**
     * The replacement tags for the asset.
     * When this field is undefined, nothing is updated.
     * Maximum length 50 tags. Each tag
     * has a maximum length of 50 characters.
     */
    tags?: Array<(string)>;
};

export type UpdateAssetResponse = {
    asset: Asset;
};

export type UpdateAssetDeprecatedRequest = {
    /**
     * The name of the asset. This is shown in the Canva UI.
     * When this field is undefined, nothing is updated.
     * Maximum length 50 characters.
     */
    name?: string;
    /**
     * The replacement tags for the asset.
     * When this field is undefined, nothing is updated.
     * Maximum length 50 tags. Each tag
     * has a maximum length of 50 characters.
     */
    tags?: Array<(string)>;
};

/**
 * The asset object, which contains metadata about the asset.
 */
export type Asset = {
    /**
     * The ID of the asset.
     */
    id: string;
    /**
     * The name of the asset.
     */
    name: string;
    /**
     * The user-facing tags attached to the asset.
     * Users can add these tags to their uploaded assets, and they can search their uploaded
     * assets in the Canva UI by searching for these tags. For information on how users use
     * tags, see the
     * [Canva Help Center page on asset tags](https://www.canva.com/help/add-edit-tags/).
     */
    tags: Array<(string)>;
    import_status?: ImportStatus;
    /**
     * When the asset was added to Canva, as a Unix timestamp (in seconds since the Unix
     * Epoch).
     */
    created_at: number;
    /**
     * When the asset was last updated in Canva, as a Unix timestamp (in seconds since the
     * Unix Epoch).
     */
    updated_at: number;
    thumbnail?: Thumbnail;
};

/**
 * The import status of the asset.
 * @deprecated
 */
export type ImportStatus = {
    state: ImportStatusState;
    error?: ImportError;
};

/**
 * State of the import job for an uploaded asset.
 * @deprecated
 */
export type ImportStatusState = 'FAILED' | 'IN_PROGRESS' | 'SUCCESS';

/**
 * State of the import job for an uploaded asset.
 * @deprecated
 */
export const ImportStatusState = {
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
    SUCCESS: 'SUCCESS'
} as const;

/**
 * If the import fails, this object provides details about the error.
 * @deprecated
 */
export type ImportError = {
    code: ImportErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    message: string;
};

/**
 * A short string indicating why the upload failed. This field can be used to handle errors programmatically.
 *
 * @deprecated
 */
export type ImportErrorCode = 'FILE_TOO_BIG' | 'IMPORT_FAILED';

/**
 * A short string indicating why the upload failed. This field can be used to handle errors programmatically.
 *
 * @deprecated
 */
export const ImportErrorCode = {
    FILE_TOO_BIG: 'FILE_TOO_BIG',
    IMPORT_FAILED: 'IMPORT_FAILED'
} as const;

/**
 * Metadata about the asset that you include as a header parameter when uploading an asset.
 * @deprecated
 */
export type UploadMetadata = {
    /**
     * The name of the asset. The maximum length of this property is 50 characters.
     */
    name: string;
    /**
     * The ID of the parent folder where the asset will be uploaded.
     */
    parent_folder_id: string;
    /**
     * The user-facing tags attached to the asset. Users can also add these tags to their uploaded assets, and they can search their uploaded assets in the Canva UI by searching for these tags. For information on how users use tags, see the [Canva Help Center page on asset tags](https://www.canva.com/help/add-edit-tags/). Maximum length 50 tags. Each tag has a maximum length of 50 characters.
     */
    tags?: Array<(string)>;
};

export type CreateAssetUploadJobResponse = {
    job: AssetUploadJob;
};

export type GetAssetUploadJobResponse = {
    job: AssetUploadJob;
};

/**
 * The status of the asset upload job.
 */
export type AssetUploadJob = {
    /**
     * The ID of the asset upload job.
     */
    id: string;
    status: AssetUploadStatus;
    error?: AssetUploadError;
    asset?: Asset;
};

/**
 * Status of the asset upload job.
 */
export type AssetUploadStatus = 'FAILED' | 'IN_PROGRESS' | 'SUCCESS';

/**
 * Status of the asset upload job.
 */
export const AssetUploadStatus = {
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
    SUCCESS: 'SUCCESS'
} as const;

/**
 * If the upload fails, this object provides details about the error.
 */
export type AssetUploadError = {
    code: AssetUploadErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    message: string;
};

/**
 * A short string indicating why the upload failed. This field can be used to handle errors
 * programmatically.
 */
export type AssetUploadErrorCode = 'FILE_TOO_BIG' | 'IMPORT_FAILED';

/**
 * A short string indicating why the upload failed. This field can be used to handle errors
 * programmatically.
 */
export const AssetUploadErrorCode = {
    FILE_TOO_BIG: 'FILE_TOO_BIG',
    IMPORT_FAILED: 'IMPORT_FAILED'
} as const;

/**
 * Metadata for the asset being uploaded.
 */
export type AssetUploadMetadata = {
    /**
     * The asset's name, encoded in Base64.
     *
     * The maximum length of an asset name in Canva (unencoded) is 50 characters.
     *
     * Base64 encoding allows names containing emojis and other special
     * characters to be sent using HTTP headers.
     * For example, "My Awesome Upload 🚀" Base64 encoded
     * is `TXkgQXdlc29tZSBVcGxvYWQg8J+agA==`.
     */
    name_base64: string;
};

export type CreateDesignAutofillJobRequest = {
    /**
     * ID of the input brand template.
     */
    brand_template_id: string;
    /**
     * Title to use for the autofilled design. Must be less than 256 characters.
     *
     * If no design title is provided, the autofilled design will have the same title as the brand template.
     */
    title?: string;
    /**
     * This property is no longer used and will soon be removed.
     *
     * This property is `false` by default.
     * @deprecated
     */
    preview?: boolean;
    /**
     * Data object containing the data fields and values to autofill.
     */
    data: {
        [key: string]: DatasetValue;
    };
};

export type CreateDesignAutofillJobResponse = {
    job: DesignAutofillJob;
};

/**
 * The data field to autofill.
 */
export type DatasetValue = DatasetImageValue | DatasetTextValue;

/**
 * Data object containing the data fields and values to autofill.
 */
export type Dataset = {
    [key: string]: DatasetValue;
};

/**
 * If the data field is an image field.
 */
export type DatasetImageValue = {
    type: 'IMAGE';
    /**
     * `asset_id` of the image to insert into the template element.
     */
    asset_id: string;
};

/**
 * If the data field is a text field.
 */
export type DatasetTextValue = {
    type: 'TEXT';
    /**
     * Text to insert into the template element.
     */
    text: string;
};

export type GetDesignAutofillJobResponse = {
    job: DesignAutofillJob;
};

/**
 * Details about the autofill job.
 */
export type DesignAutofillJob = {
    /**
     * ID of the asynchronous job that is creating the design using the provided data.
     */
    id: string;
    status: DesignAutofillStatus;
    result?: DesignAutofillJobResult;
    error?: AutofillError;
};

/**
 * Result of the design autofill job. Only present if job status is `SUCCESS`.
 */
export type DesignAutofillJobResult = CreateDesignAutofillJobResult;

/**
 * Design has been created and saved to user's root folder.
 */
export type CreateDesignAutofillJobResult = {
    type: 'CREATE_DESIGN';
    design: DesignSummary;
};

/**
 * Status of the design autofill job.
 */
export type DesignAutofillStatus = 'IN_PROGRESS' | 'SUCCESS' | 'FAILED';

/**
 * Status of the design autofill job.
 */
export const DesignAutofillStatus = {
    IN_PROGRESS: 'IN_PROGRESS',
    SUCCESS: 'SUCCESS',
    FAILED: 'FAILED'
} as const;

export type AutofillErrorCode = 'AUTOFILL_ERROR' | 'THUMBNAIL_GENERATION_ERROR' | 'CREATE_DESIGN_ERROR';

export const AutofillErrorCode = {
    AUTOFILL_ERROR: 'AUTOFILL_ERROR',
    THUMBNAIL_GENERATION_ERROR: 'THUMBNAIL_GENERATION_ERROR',
    CREATE_DESIGN_ERROR: 'CREATE_DESIGN_ERROR'
} as const;

/**
 * If the autofill job fails, this object provides details about the error.
 */
export type AutofillError = {
    code: AutofillErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    message: string;
};

export type ListBrandTemplatesResponse = {
    /**
     * If the success response contains a continuation token, the user has access to more
     * brand templates you can list. You can use this token as a query parameter and retrieve
     * more templates from the list, for example
     * `/v1/brand-templates?continuation={continuation}`.
     * To retrieve all the brand templates available to the user, you might need to make
     * multiple requests.
     */
    continuation?: string;
    /**
     * The list of brand templates.
     */
    items: Array<BrandTemplate>;
};

/**
 * Successful response from a `getBrandTemplate` request.
 */
export type GetBrandTemplateResponse = {
    brand_template: BrandTemplate;
};

/**
 * An object representing a brand template with associated metadata.
 */
export type BrandTemplate = {
    /**
     * The brand template ID.
     */
    id: string;
    /**
     * The brand template title, as shown in the Canva UI.
     */
    title: string;
    /**
     * A URL Canva users can visit to view the brand template.
     */
    view_url: string;
    /**
     * A URL Canva users can visit to create a new design from the template.
     */
    create_url: string;
    thumbnail?: Thumbnail;
};

/**
 * Successful response from a `getBrandTemplateDataset` request.
 */
export type GetBrandTemplateDatasetResponse = {
    /**
     * The dataset definition for the brand template. The dataset definition contains the data inputs available for use with the
     * [Create design autofill job API](https://www.canva.dev/docs/connect/api-reference/autofills/create-design-autofill-job/).
     */
    dataset?: {
        [key: string]: DataField;
    };
};

/**
 * The dataset definition for the brand template. The dataset definition contains the data inputs available for use with the
 * [Create design autofill job API](https://www.canva.dev/docs/connect/api-reference/autofills/create-design-autofill-job/).
 */
export type DatasetDefinition = {
    [key: string]: DataField;
};

/**
 * A named data field that can be autofilled in the brand template.
 */
export type DataField = ImageDataField | TextDataField;

/**
 * An image for a brand template. You can autofill the brand template with an image by providing its `asset_id`.
 */
export type ImageDataField = {
    type: 'IMAGE';
};

/**
 * Some text for a brand template. You can autofill the brand template with this value.
 */
export type TextDataField = {
    type: 'TEXT';
};

export type CreateCommentRequest = {
    attached_to: CommentObjectInput;
    /**
     * The comment message. This is the comment body shown in the Canva UI.
     *
     * You can also mention users in your message by specifying their User ID and Team ID
     * using the format `[user_id:team_id]`. If the `assignee_id` parameter is specified, you
     * must mention the assignee in the message.
     */
    message: string;
    /**
     * Lets you assign the comment to a Canva user using their User ID. You _must_ mention the
     * assigned user in the `message`.
     */
    assignee_id?: string;
};

export type CreateReplyRequest = {
    attached_to: CommentObjectInput;
    /**
     * The reply comment message. This is the reply comment body shown in the Canva UI.
     *
     * You can also mention users in your message by specifying their User ID and Team ID
     * using the format `[user_id:team_id]`.
     */
    message: string;
};

export type CreateCommentResponse = {
    comment: ParentComment;
};

export type CreateReplyResponse = {
    comment: ReplyComment;
};

/**
 * Successful response from a `getComment` request.
 */
export type GetCommentResponse = {
    comment: Comment;
};

/**
 * The comment object, which contains metadata about the comment.
 */
export type Comment = ParentComment | ReplyComment;

/**
 * Data about the comment, including the message, author, and
 * the object (such as a design) the comment is attached to.
 */
export type ParentComment = {
    type: 'PARENT';
    /**
     * The ID of the comment.
     *
     * You can use this ID to create replies to the comment using the [Create reply API](https://www.canva.dev/docs/connect/api-reference/comments/create-reply/).
     */
    id: string;
    attached_to?: CommentObject;
    /**
     * The comment message. This is the comment body shown in the Canva UI.
     * User mentions are shown here in the format `[user_id:team_id]`.
     */
    message: string;
    author: User;
    /**
     * When the comment or reply was created, as a Unix timestamp
     * (in seconds since the Unix Epoch).
     */
    created_at?: number;
    /**
     * When the comment or reply was last updated, as a Unix timestamp
     * (in seconds since the Unix Epoch).
     */
    updated_at?: number;
    /**
     * The Canva users mentioned in the comment.
     */
    mentions: {
        [key: string]: TeamUser;
    };
    assignee?: User;
    resolver?: User;
};

/**
 * Data about the reply comment, including the message, author, and
 * the object (such as a design) the comment is attached to.
 */
export type ReplyComment = {
    type: 'REPLY';
    /**
     * The ID of the comment.
     */
    id: string;
    attached_to?: CommentObject;
    /**
     * The comment message. This is the comment body shown in the Canva UI.
     * User mentions are shown here in the format `[user_id:team_id]`.
     */
    message: string;
    author: User;
    /**
     * When the comment or reply was created, as a Unix timestamp
     * (in seconds since the Unix Epoch).
     */
    created_at?: number;
    /**
     * When the comment or reply was last updated, as a Unix timestamp
     * (in seconds since the Unix Epoch).
     */
    updated_at?: number;
    /**
     * The Canva users mentioned in the comment.
     */
    mentions: {
        [key: string]: TeamUser;
    };
    /**
     * The ID of the comment thread this reply is in. This ID is the same as the `id` of the
     * parent comment.
     */
    thread_id: string;
};

/**
 * Identifying information about the object (such as a design) that the comment is attached to.
 */
export type CommentObject = DesignCommentObject;

/**
 * If the comment is attached to a Canva Design.
 */
export type DesignCommentObject = {
    type: 'DESIGN';
    /**
     * The ID of the design this comment is attached to.
     */
    design_id: string;
};

/**
 * An object containing identifying information for the design or other object you want to
 * attach the comment to.
 */
export type CommentObjectInput = DesignCommentObjectInput;

/**
 * If the comment is attached to a Canva Design.
 */
export type DesignCommentObjectInput = {
    type: 'DESIGN';
    /**
     * The ID of the design you want to attach this comment to.
     */
    design_id: string;
};

/**
 * Basic details about the comment.
 */
export type CommentEvent = {
    type: CommentEventType;
    data: Comment;
};

/**
 * The Canva users mentioned in the comment.
 */
export type Mentions = {
    [key: string]: TeamUser;
};

/**
 * The type of comment event.
 */
export type CommentEventType = 'COMMENT' | 'REPLY' | 'MENTION' | 'ASSIGN' | 'RESOLVE';

/**
 * The type of comment event.
 */
export const CommentEventType = {
    COMMENT: 'COMMENT',
    REPLY: 'REPLY',
    MENTION: 'MENTION',
    ASSIGN: 'ASSIGN',
    RESOLVE: 'RESOLVE'
} as const;

export type GetSigningPublicKeysResponse = {
    /**
     * A Json Web Key Set (JWKS) with public keys used for signing webhooks. You can use this JWKS
     * to verify that a webhook was sent from Canva.
     */
    keys: Array<EdDsaJwk>;
};

/**
 * A JSON Web Key Set (JWKS) using the Edwards-curve Digital Signature Algorithm (EdDSA), as
 * described in [RFC-8037](https://www.rfc-editor.org/rfc/rfc8037.html#appendix-A).
 */
export type EdDsaJwk = {
    /**
     * The `kid` (key ID) is a unique identifier for a public key. When the keys used
     * to sign webhooks are rotated, you can use this ID to select the correct key
     * within a JWK Set during the key rollover. The `kid` value is case-sensitive.
     */
    kid: string;
    /**
     * The `kty` (key type) identifies the cryptographic algorithm family used with
     * the key, such as "RSA" or "EC". Only Octet Key Pairs
     * (`OKPs`) are supported.
     * The `kty` value is case-sensitive. For more information on the `kty` property
     * and OKPs, see [RFC-8037 — "kty" (Key Type)
     * Parameter](https://www.rfc-editor.org/rfc/rfc8037.html#section-2).
     */
    kty: string;
    /**
     * The `crv` (curve) property identifies the curve used for elliptical curve
     * encryptions. Only "Ed25519" is supported. For more information on the `crv`
     * property, see [RFC-8037 — Key Type
     * "OKP"](https://www.rfc-editor.org/rfc/rfc8037.html#section-2).
     */
    crv: string;
    /**
     * The `x` property is the public key of an elliptical curve encryption. The key
     * is Base64urlUInt-encoded. For more information on the `x` property, see
     * [RFC-8037 — "x" (X Coordinate)
     * Parameter](https://www.rfc-editor.org/rfc/rfc8037#section-2).
     */
    x: string;
};

export type GetListDesignResponse = {
    /**
     * A continuation token.
     * If the success response contains a continuation token, the list contains more designs
     * you can list. You can use this token as a query parameter and retrieve more
     * designs from the list, for example
     * `/v1/designs?continuation={continuation}`.
     *
     * To retrieve all of a user's designs, you might need to make multiple requests.
     */
    continuation?: string;
    /**
     * The list of designs.
     */
    items: Array<Design>;
};

/**
 * Body parameters for creating a new design.
 * At least one of `design_type` or `asset_id` must be defined
 * to create a new design.
 */
export type CreateDesignRequest = {
    design_type?: DesignTypeInput;
    /**
     * The ID of an asset to insert into the created design.
     */
    asset_id?: string;
    /**
     * The name of the design. Must be less than 256 characters.
     */
    title?: string;
};

/**
 * Details about the new design.
 */
export type CreateDesignResponse = {
    design: Design;
};

/**
 * Successful response from a `getDesign` request.
 */
export type GetDesignResponse = {
    design: Design;
};

/**
 * The design object, which contains metadata about the design.
 */
export type Design = {
    /**
     * The design ID.
     */
    id: string;
    /**
     * The design title.
     */
    title?: string;
    owner: TeamUserSummary;
    thumbnail?: Thumbnail;
    urls: DesignLinks;
};

/**
 * A temporary set of URLs for viewing or editing the design.
 */
export type DesignLinks = {
    /**
     * A temporary editing URL for the design.
     *
     * NOTE: This is not a permanent URL, it is only valid for 30 days.
     */
    edit_url: string;
    /**
     * A temporary viewing URL for the design.
     *
     * NOTE: This is not a permanent URL, it is only valid for 30 days.
     *
     */
    view_url: string;
};

/**
 * Basic details about the design, such as the design's ID, title, and URL.
 */
export type DesignSummary = {
    /**
     * The design ID.
     */
    id?: string;
    /**
     * The design title.
     */
    title?: string;
    /**
     * URL of the design.
     */
    url?: string;
    thumbnail?: Thumbnail;
};

/**
 * Metadata about the design that you include as a header parameter when importing a design.
 */
export type DesignImportMetadata = {
    /**
     * The design's title, encoded in Base64.
     *
     * The maximum length of a design title in Canva (unencoded) is 50 characters.
     *
     * Base64 encoding allows titles containing emojis and other special
     * characters to be sent using HTTP headers.
     * For example, "My Awesome Design 😍" Base64 encoded
     * is `TXkgQXdlc29tZSBEZXNpZ24g8J+YjQ==`.
     */
    title_base64: string;
};

export type CreateDesignImportJobResponse = {
    /**
     * The design import job ID.
     */
    job_id: string;
};

/**
 * The status of the design import.
 */
export type DesignImportStatus = {
    state: DesignImportStatusState;
    error?: DesignImportError;
};

/**
 * State of the design import job.
 */
export type DesignImportStatusState = 'FAILED' | 'IMPORTING' | 'SUCCESS';

/**
 * State of the design import job.
 */
export const DesignImportStatusState = {
    FAILED: 'FAILED',
    IMPORTING: 'IMPORTING',
    SUCCESS: 'SUCCESS'
} as const;

/**
 * Information about why the import failed.
 */
export type DesignImportError = {
    code: DesignImportErrorCode;
    /**
     * A human-readable description of why the import failed.
     */
    message: string;
};

/**
 * A short string about why the import failed. You can programmatically
 * handle errors using this field.
 */
export type DesignImportErrorCode = 'DESIGN_CREATION_THROTTLED' | 'DESIGN_IMPORT_THROTTLED' | 'DUPLICATE_IMPORT' | 'INTERNAL_SERVER_ERROR' | 'INVALID_FILE';

/**
 * A short string about why the import failed. You can programmatically
 * handle errors using this field.
 */
export const DesignImportErrorCode = {
    DESIGN_CREATION_THROTTLED: 'DESIGN_CREATION_THROTTLED',
    DESIGN_IMPORT_THROTTLED: 'DESIGN_IMPORT_THROTTLED',
    DUPLICATE_IMPORT: 'DUPLICATE_IMPORT',
    INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
    INVALID_FILE: 'INVALID_FILE'
} as const;

export type GetDesignImportJobResponse = {
    /**
     * The design import job ID.
     */
    job_id: string;
    status: DesignImportStatus;
    /**
     * A list of designs imported from the external file. It usually contains one item.
     * Imports with a large number of pages or assets are split into multiple designs.
     */
    designs?: Array<Design>;
};

/**
 * The desired design type.
 */
export type DesignTypeInput = PresetDesignTypeInput | CustomDesignTypeInput;

/**
 * Provide the common design type.
 */
export type PresetDesignTypeInput = {
    type: 'PRESET';
    name: PresetDesignTypeName;
};

/**
 * The name of the design type. This can be one of the following:
 *
 * - `DOC`: A [Canva doc](https://www.canva.com/docs/); a document for Canva's online text editor.
 * - `WHITEBOARD`: A [whiteboard](https://www.canva.com/online-whiteboard/); a design which gives you infinite space to collaborate.
 * - `PRESENTATION`: A [presentation](https://www.canva.com/presentations/); lets you create and collaborate for presenting to an audience.
 */
export type PresetDesignTypeName = 'DOC' | 'WHITEBOARD' | 'PRESENTATION';

/**
 * The name of the design type. This can be one of the following:
 *
 * - `DOC`: A [Canva doc](https://www.canva.com/docs/); a document for Canva's online text editor.
 * - `WHITEBOARD`: A [whiteboard](https://www.canva.com/online-whiteboard/); a design which gives you infinite space to collaborate.
 * - `PRESENTATION`: A [presentation](https://www.canva.com/presentations/); lets you create and collaborate for presenting to an audience.
 */
export const PresetDesignTypeName = {
    DOC: 'DOC',
    WHITEBOARD: 'WHITEBOARD',
    PRESENTATION: 'PRESENTATION'
} as const;

/**
 * Provide the width and height to define a custom design type.
 */
export type CustomDesignTypeInput = {
    type: 'CUSTOM';
    /**
     * The width of the design (in pixels). Minimum 40px, maximum 8000px.
     */
    width: number;
    /**
     * The height of the design (in pixels). Minimum 40px, maximum 8000px.
     */
    height: number;
};

export type Error = {
    code: ErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    message: string;
};

export type OauthError = {
    error: ErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    error_description: string;
};

/**
 * A short string indicating what failed. This field can be used to handle errors programmatically.
 *
 */
export type ErrorCode = 'INTERNAL_ERROR' | 'INVALID_FIELD' | 'INVALID_HEADER_VALUE' | 'PERMISSION_DENIED' | 'TOO_MANY_REQUESTS' | 'NOT_FOUND' | 'BAD_REQUEST_BODY' | 'BAD_HTTP_METHOD' | 'BAD_REQUEST_PARAMS' | 'BAD_QUERY_PARAMS' | 'ENDPOINT_NOT_FOUND' | 'UNSUPPORTED_VERSION' | 'INVALID_ACCESS_TOKEN' | 'REVOKED_ACCESS_TOKEN' | 'MISSING_FIELD' | 'MISSING_SCOPE' | 'invalid_grant' | 'invalid_request' | 'invalid_client' | 'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope' | 'INVALID_BASIC_HEADER' | 'INVALID_FILE_FORMAT' | 'QUOTA_EXCEEDED' | 'UNSUPPORTED_CONTENT_TYPE' | 'REQUEST_TOO_LARGE' | 'FOLDER_NOT_FOUND' | 'ASSET_NOT_FOUND' | 'MAX_LIMIT_REACHED' | 'PERMISSION_NOT_FOUND' | 'PERMISSION_EXISTS' | 'UNAUTHORIZED_USER' | 'USER_NOT_FOUND' | 'GROUP_NOT_FOUND' | 'APP_NOT_FOUND' | 'CONTENT_NOT_FOUND' | 'DOCTYPE_NOT_FOUND' | 'DESIGN_NOT_FOUND' | 'DESIGN_TYPE_NOT_FOUND' | 'TEAM_NOT_FOUND' | 'COMMENT_NOT_FOUND' | 'TOO_MANY_COMMENTS' | 'TOO_MANY_REPLIES' | 'MESSAGE_TOO_LONG' | 'DESIGN_NOT_FILLABLE' | 'AUTOFILL_DATA_INVALID' | 'FEATURE_NOT_AVAILABLE' | 'LICENSE_REQUIRED';

/**
 * A short string indicating what failed. This field can be used to handle errors programmatically.
 *
 */
export const ErrorCode = {
    INTERNAL_ERROR: 'INTERNAL_ERROR',
    INVALID_FIELD: 'INVALID_FIELD',
    INVALID_HEADER_VALUE: 'INVALID_HEADER_VALUE',
    PERMISSION_DENIED: 'PERMISSION_DENIED',
    TOO_MANY_REQUESTS: 'TOO_MANY_REQUESTS',
    NOT_FOUND: 'NOT_FOUND',
    BAD_REQUEST_BODY: 'BAD_REQUEST_BODY',
    BAD_HTTP_METHOD: 'BAD_HTTP_METHOD',
    BAD_REQUEST_PARAMS: 'BAD_REQUEST_PARAMS',
    BAD_QUERY_PARAMS: 'BAD_QUERY_PARAMS',
    ENDPOINT_NOT_FOUND: 'ENDPOINT_NOT_FOUND',
    UNSUPPORTED_VERSION: 'UNSUPPORTED_VERSION',
    INVALID_ACCESS_TOKEN: 'INVALID_ACCESS_TOKEN',
    REVOKED_ACCESS_TOKEN: 'REVOKED_ACCESS_TOKEN',
    MISSING_FIELD: 'MISSING_FIELD',
    MISSING_SCOPE: 'MISSING_SCOPE',
    INVALID_GRANT: 'invalid_grant',
    INVALID_REQUEST: 'invalid_request',
    INVALID_CLIENT: 'invalid_client',
    UNAUTHORIZED_CLIENT: 'unauthorized_client',
    UNSUPPORTED_GRANT_TYPE: 'unsupported_grant_type',
    INVALID_SCOPE: 'invalid_scope',
    INVALID_BASIC_HEADER: 'INVALID_BASIC_HEADER',
    INVALID_FILE_FORMAT: 'INVALID_FILE_FORMAT',
    QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',
    UNSUPPORTED_CONTENT_TYPE: 'UNSUPPORTED_CONTENT_TYPE',
    REQUEST_TOO_LARGE: 'REQUEST_TOO_LARGE',
    FOLDER_NOT_FOUND: 'FOLDER_NOT_FOUND',
    ASSET_NOT_FOUND: 'ASSET_NOT_FOUND',
    MAX_LIMIT_REACHED: 'MAX_LIMIT_REACHED',
    PERMISSION_NOT_FOUND: 'PERMISSION_NOT_FOUND',
    PERMISSION_EXISTS: 'PERMISSION_EXISTS',
    UNAUTHORIZED_USER: 'UNAUTHORIZED_USER',
    USER_NOT_FOUND: 'USER_NOT_FOUND',
    GROUP_NOT_FOUND: 'GROUP_NOT_FOUND',
    APP_NOT_FOUND: 'APP_NOT_FOUND',
    CONTENT_NOT_FOUND: 'CONTENT_NOT_FOUND',
    DOCTYPE_NOT_FOUND: 'DOCTYPE_NOT_FOUND',
    DESIGN_NOT_FOUND: 'DESIGN_NOT_FOUND',
    DESIGN_TYPE_NOT_FOUND: 'DESIGN_TYPE_NOT_FOUND',
    TEAM_NOT_FOUND: 'TEAM_NOT_FOUND',
    COMMENT_NOT_FOUND: 'COMMENT_NOT_FOUND',
    TOO_MANY_COMMENTS: 'TOO_MANY_COMMENTS',
    TOO_MANY_REPLIES: 'TOO_MANY_REPLIES',
    MESSAGE_TOO_LONG: 'MESSAGE_TOO_LONG',
    DESIGN_NOT_FILLABLE: 'DESIGN_NOT_FILLABLE',
    AUTOFILL_DATA_INVALID: 'AUTOFILL_DATA_INVALID',
    FEATURE_NOT_AVAILABLE: 'FEATURE_NOT_AVAILABLE',
    LICENSE_REQUIRED: 'LICENSE_REQUIRED'
} as const;

/**
 * Body parameters for starting an export job for a design.
 * It must include a design ID, and one of the supported export formats.
 */
export type CreateDesignExportJobRequest = {
    /**
     * The design ID.
     */
    design_id: string;
    format: ExportFormat;
};

/**
 * Details about the desired export format.
 */
export type ExportFormat = PdfExportFormat | JpgExportFormat | PngExportFormat | PptxExportFormat | GifExportFormat | Mp4ExportFormat;

/**
 * Export the design as a PDF. Providing a paper size is optional. The default paper size is A4.
 */
export type PdfExportFormat = {
    type: 'PDF';
    export_quality?: ExportQuality;
    size?: ExportPageSize;
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

/**
 * Export the design as a GIF. Height or width (or both) may be specified, otherwise the file
 * will be exported at it's default size. Large designs will be scaled down, and aspect ratio
 * will always be maintained.
 */
export type GifExportFormat = {
    type: 'GIF';
    export_quality?: ExportQuality;
    /**
     * Specify the height in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    height?: number;
    /**
     * Specify the width in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    width?: number;
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

/**
 * Export the design as a JPG. Compression quality must be provided. Height or width (or both)
 * may be specified, otherwise the file will be exported at it's default size.
 */
export type JpgExportFormat = {
    type: 'JPG';
    export_quality?: ExportQuality;
    /**
     * For the `JPG` type, the `quality` of the exported JPEG determines how compressed the exported file should be. A _low_ `quality` value (minimum `1`) will create a file with a smaller file size, but the resulting file will have pixelated artifacts when compared to a file created with a _high_ `quality` value (maximum `100`).
     */
    quality: number;
    /**
     * Specify the height in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    height?: number;
    /**
     * Specify the width in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    width?: number;
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

/**
 * Export the design as a PNG. Height or width (or both) may be specified, otherwise
 * the file will be exported at it's default size. You may also specify whether to export the
 * file losslessly, and whether to export a multi-page design as a single image.
 */
export type PngExportFormat = {
    type: 'PNG';
    export_quality?: ExportQuality;
    /**
     * Specify the height in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    height?: number;
    /**
     * Specify the width in pixels of the exported image. If only one of height or width is
     * specified, then the image will be scaled to match that dimension, respecting the design's
     * aspect ratio. If no width or height is specified, the image will be exported using the
     * dimensions of the design.
     */
    width?: number;
    /**
     * When `true`, the PNG is compressed with a lossless compression algorithm (`false` by
     * default).
     */
    lossless?: boolean;
    /**
     * When `true`, multi-page designs are merged into a single image.
     * When `false` (default), each page is exported as a separate image.
     */
    as_single_image?: boolean;
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

/**
 * Export the design as a PPTX.
 */
export type PptxExportFormat = {
    type: 'PPTX';
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

/**
 * Export the design as an MP4. You must specify the quality of the exported video.
 */
export type Mp4ExportFormat = {
    type: 'MP4';
    export_quality?: ExportQuality;
    quality: Mp4ExportQuality;
    /**
     * To specify which pages to export in a multi-page design, provide the page numbers as
     * an array. The first page in a design is page `1`.
     * If `pages` isn't specified, all the pages are exported.
     */
    pages?: Array<(number)>;
};

export type CreateDesignExportJobResponse = {
    job: ExportJob;
};

export type GetDesignExportJobResponse = {
    job: ExportJob;
};

/**
 * The status of the export job.
 */
export type ExportJob = {
    /**
     * The export job ID.
     */
    id: string;
    status: DesignExportStatus;
    /**
     * When the export job is completed, also returns a list of urls for the exported
     * resources. The list is sorted by page order.
     */
    urls?: Array<(string)>;
    error?: ExportError;
};

/**
 * The paper size of the export PDF file. The `size` attribute is only supported for Documents (Canva Docs).
 */
export type ExportPageSize = 'A4' | 'A3' | 'LETTER' | 'LEGAL';

/**
 * The paper size of the export PDF file. The `size` attribute is only supported for Documents (Canva Docs).
 */
export const ExportPageSize = {
    A4: 'A4',
    A3: 'A3',
    LETTER: 'LETTER',
    LEGAL: 'LEGAL'
} as const;

/**
 * The export status of the job. A newly created job will be `IN_PROGRESS` and will eventually
 * become `SUCCESS` or `FAILED`.
 */
export type DesignExportStatus = 'FAILED' | 'IN_PROGRESS' | 'SUCCESS';

/**
 * The export status of the job. A newly created job will be `IN_PROGRESS` and will eventually
 * become `SUCCESS` or `FAILED`.
 */
export const DesignExportStatus = {
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
    SUCCESS: 'SUCCESS'
} as const;

/**
 * Specify the height in pixels of the exported image. If only one of height or width is
 * specified, then the image will be scaled to match that dimension, respecting the design's
 * aspect ratio. If no width or height is specified, the image will be exported using the
 * dimensions of the design.
 */
export type ExportHeight = number;

/**
 * Specify the width in pixels of the exported image. If only one of height or width is
 * specified, then the image will be scaled to match that dimension, respecting the design's
 * aspect ratio. If no width or height is specified, the image will be exported using the
 * dimensions of the design.
 */
export type ExportWidth = number;

/**
 * The orientation and resolution of the exported video. Orientation is either `HORIZONTAL` or
 * `VERTICAL`, and resolution is one of `480P`, `720P`, `1080P` or `4K`.
 */
export type Mp4ExportQuality = 'HORIZONTAL_480P' | 'HORIZONTAL_720P' | 'HORIZONTAL_1080P' | 'HORIZONTAL_4K' | 'VERTICAL_480P' | 'VERTICAL_720P' | 'VERTICAL_1080P' | 'VERTICAL_4K';

/**
 * The orientation and resolution of the exported video. Orientation is either `HORIZONTAL` or
 * `VERTICAL`, and resolution is one of `480P`, `720P`, `1080P` or `4K`.
 */
export const Mp4ExportQuality = {
    HORIZONTAL_480P: 'HORIZONTAL_480P',
    HORIZONTAL_720P: 'HORIZONTAL_720P',
    HORIZONTAL_1080P: 'HORIZONTAL_1080P',
    HORIZONTAL_4K: 'HORIZONTAL_4K',
    VERTICAL_480P: 'VERTICAL_480P',
    VERTICAL_720P: 'VERTICAL_720P',
    VERTICAL_1080P: 'VERTICAL_1080P',
    VERTICAL_4K: 'VERTICAL_4K'
} as const;

/**
 * If the export fails, this object provides details about the error.
 */
export type ExportError = {
    code?: ExportErrorCode;
    /**
     * A human-readable description of what went wrong.
     */
    message?: string;
};

/**
 * If the export failed, this specifies the reason why it failed. This can be one of the following:
 *
 * - `LICENSE_REQUIRED`: The design contains [premium elements](https://www.canva.com/help/premium-elements/) that haven't been purchased. You can either buy the elements or upgrade to a Canva plan (such as Canva Pro) that has premium features, then try again. Alternatively, you can set `export_quality` to `regular` to export your document in regular quality.
 * - `INTERNAL_FAILURE`: The service encountered an error when exporting your design.
 */
export type ExportErrorCode = 'LICENSE_REQUIRED' | 'INTERNAL_FAILURE';

/**
 * If the export failed, this specifies the reason why it failed. This can be one of the following:
 *
 * - `LICENSE_REQUIRED`: The design contains [premium elements](https://www.canva.com/help/premium-elements/) that haven't been purchased. You can either buy the elements or upgrade to a Canva plan (such as Canva Pro) that has premium features, then try again. Alternatively, you can set `export_quality` to `regular` to export your document in regular quality.
 * - `INTERNAL_FAILURE`: The service encountered an error when exporting your design.
 */
export const ExportErrorCode = {
    LICENSE_REQUIRED: 'LICENSE_REQUIRED',
    INTERNAL_FAILURE: 'INTERNAL_FAILURE'
} as const;

/**
 * Specifies the export quality of the design. This can be one of the following:
 * - `REGULAR`: Regular quality export. This is the default.
 * - `PRO`: Premium quality export.
 *
 * NOTE: A `PRO` export might fail if the design contains [premium elements](https://www.canva.com/help/premium-elements/) and the calling user either hasn't purchased the elements or isn't on a Canva plan (such as Canva Pro) that has premium features.
 */
export type ExportQuality = 'PRO' | 'REGULAR';

/**
 * Specifies the export quality of the design. This can be one of the following:
 * - `REGULAR`: Regular quality export. This is the default.
 * - `PRO`: Premium quality export.
 *
 * NOTE: A `PRO` export might fail if the design contains [premium elements](https://www.canva.com/help/premium-elements/) and the calling user either hasn't purchased the elements or isn't on a Canva plan (such as Canva Pro) that has premium features.
 */
export const ExportQuality = {
    PRO: 'PRO',
    REGULAR: 'REGULAR'
} as const;

/**
 * The folder ID.
 */
export type GetFolderResponse = {
    folder: Folder;
};

/**
 * Body parameters for creating a new folder.
 */
export type CreateFolderRequest = {
    /**
     * The name of the folder. Must be less than 256 characters.
     */
    name: string;
    /**
     * The folder ID of the parent folder. To create a new folder at the top level of a user's
     * [projects](https://www.canva.com/help/find-designs-and-folders/), use the ID `root`.
     */
    parent_folder_id: string;
};

/**
 * Details about the new folder.
 */
export type CreateFolderResponse = {
    folder?: Folder;
};

/**
 * Body parameters for updating the folder's details.
 */
export type UpdateFolderRequest = {
    /**
     * The folder name, as shown in the Canva UI.
     */
    name: string;
};

/**
 * Details about the updated folder.
 */
export type UpdateFolderResponse = {
    folder?: Folder;
};

/**
 * A list of the items in a folder.
 * If the success response contains a continuation token, the folder contains more items
 * you can list. You can use this token as a query parameter and retrieve more
 * items from the list, for example
 * `/v1/folders/{folderId}/items?continuation={continuation}`.
 *
 * To retrieve all the items in a folder, you might need to make multiple requests.
 */
export type ListFolderItemsResponse = {
    /**
     * An array of items in the folder.
     */
    items: Array<FolderItemSummary>;
    /**
     * If the success response contains a continuation token, the folder contains more items
     * you can list. You can use this token as a query parameter and retrieve more
     * items from the list, for example
     * `/v1/folders/{folderId}/items?continuation={continuation}`.
     *
     * To retrieve all the items in a folder, you might need to make multiple requests.
     */
    continuation?: string;
};

/**
 * Details about the folder item.
 */
export type FolderItemSummary = AssetItem | FolderItem | DesignItem | TemplateItem;

/**
 * Details about the asset.
 */
export type AssetItem = {
    type: 'ASSET';
    asset: Asset;
};

/**
 * Details about the folder.
 */
export type FolderItem = {
    type: 'FOLDER';
    folder: Folder;
};

/**
 * Details about the design.
 */
export type DesignItem = {
    type: 'DESIGN';
    design: Design;
};

/**
 * Details about the template.
 */
export type TemplateItem = {
    type: 'TEMPLATE';
    template: Template;
};

/**
 * Body parameters for moving the folder.
 */
export type MoveFolderItemRequest = {
    /**
     * The ID of the folder that contains the item you want to move (the source folder).
     * If the item is in the top level of a Canva user's
     * [projects](https://www.canva.com/help/find-designs-and-folders/), use the ID `root`.
     */
    from_folder_id: string;
    /**
     * The ID of the folder you want to move the item to (the destination folder).
     * If you want to move the item to the top level of a Canva user's
     * [projects](https://www.canva.com/help/find-designs-and-folders/), use the ID `root`.
     */
    to_folder_id: string;
    /**
     * The ID of the item you want to move.
     */
    item_id: string;
};

/**
 * The folder object, which contains metadata about the folder.
 */
export type Folder = {
    /**
     * The folder ID.
     */
    id: string;
    /**
     * The folder name.
     */
    name: string;
    /**
     * When the folder was created, as a Unix timestamp (in seconds since the
     * Unix Epoch).
     */
    created_at: number;
    /**
     * When the folder was last updated, as a Unix timestamp (in seconds since the
     * Unix Epoch).
     */
    updated_at: number;
    thumbnail?: Thumbnail;
};

/**
 * This object contains some folder metadata. You can retrieve additional metadata
 * using the folder ID and the `/v1/folders/{folderId}` endpoint.
 */
export type FolderSummary = {
    /**
     * The folder ID.
     */
    id?: string;
    /**
     * The folder name, as shown in the Canva UI.
     */
    title?: string;
    /**
     * The folder URL.
     */
    url?: string;
};

/**
 * Metadata for the Canva Group, consisting of the Group ID,
 * display name, and whether it's an external Canva Group.
 */
export type Group = {
    /**
     * The ID of the group with permissions to access the design.
     */
    id: string;
    /**
     * The display name of the group.
     */
    display_name?: string;
    /**
     * Is the user making the API call (the authenticated user) and the Canva Group
     * from different Canva Teams?
     *
     * - When `true`, the user and the group aren't in the same Canva Team.
     * - When `false`, the user and the group are in the same Canva Team.
     */
    external: boolean;
};

export type ExchangeAccessTokenRequest = ExchangeAuthCodeRequest | ExchangeRefreshTokenRequest;

export type ExchangeAuthCodeRequest = {
    /**
     * For exchanging an authorization code for an access token.
     */
    grant_type: 'authorization_code';
    /**
     * The `code_verifier` value that you generated when creating the user authorization URL.
     */
    code_verifier: string;
    /**
     * The authorization code you received after the user authorized the integration.
     */
    code: string;
    /**
     * Your integration's unique ID, for authenticating the request.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_id?: string;
    /**
     * Your integration's client secret, for authenticating the request. Begins with `cnvca`.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_secret?: string;
    /**
     * Only required if a redirect URL was supplied when you [created the user authorization URL](https://www.canva.dev/docs/connect/authentication/#create-the-authorization-url).
     *
     * Must be one of those already specified by the client. If not supplied, the first redirect_uri defined for the client will be used by default.
     *
     */
    redirect_uri?: string;
};

export type ExchangeRefreshTokenRequest = {
    /**
     * For generating an access token using a refresh token.
     */
    grant_type: 'refresh_token';
    /**
     * Your integration's unique ID, for authenticating the request.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_id?: string;
    /**
     * Your integration's client secret, for authenticating the request. Begins with `cnvca`.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_secret?: string;
    /**
     * The refresh token to be exchanged. You can copy this value from the successful response received when generating an access token.
     */
    refresh_token: string;
    /**
     * Optional scope value when refreshing an access token. Separate multiple [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) with a single space between each scope.
     *
     * The requested scope cannot include any permissions not already granted, so this parameter allows you to limit the scope when refreshing a token. If omitted, the scope for the token remains unchanged.
     *
     */
    scope?: string;
};

/**
 * Exchange auth token to access token.
 */
export type ExchangeAccessTokenResponse = {
    /**
     * The bearer access token to use to authenticate to Canva Connect API endpoints. If requested using a `authorization_code` or `refresh_token`, this allows you to act on behalf of a user.
     */
    access_token: string;
    /**
     * The token that you can use to refresh the access token.
     */
    refresh_token: string;
    /**
     * The token type returned. This is always `Bearer`.
     */
    token_type: string;
    /**
     * The expiry time (in seconds) for the token.
     */
    expires_in: number;
    /**
     * The [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) that the token has been granted.
     */
    scope?: string;
};

export type IntrospectTokenRequest = {
    /**
     * The token to introspect.
     */
    token: string;
    /**
     * Your integration's unique ID, for authenticating the request.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_id?: string;
    /**
     * Your integration's client secret, for authenticating the request. Begins with `cnvca`.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_secret?: string;
};

/**
 * Introspection result of access or refresh tokens
 */
export type IntrospectTokenResponse = {
    /**
     * Whether the access token is active.
     *
     * If `true`, the access token is valid and active. If `false`, the access token is invalid.
     *
     */
    active: boolean;
    /**
     * The [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) that the token has been granted.
     */
    scope?: string;
    /**
     * The ID of the client that requested the token.
     */
    client?: string;
    /**
     * The expiration time of the token, as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) in seconds.
     */
    exp?: number;
    /**
     * When the token was issued, as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) in seconds.
     */
    iat?: number;
    /**
     * The "not before" time of the token, which specifies the time before which the access token most not be accepted, as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) in seconds.
     */
    nbf?: number;
    /**
     * A unique ID for the access token.
     */
    jti?: string;
    /**
     * The subject of the claim. This is the ID of the Canva user that the access token acts on behalf of.
     *
     * This is an obfuscated value, so a single user has a unique ID for each integration. If the same user authorizes another integration, their ID in that other integration is different.
     *
     */
    sub?: string;
};

/**
 * Supply an access token or refresh token to have its lineage revoked.
 */
export type RevokeTokensRequest = {
    /**
     * The token to revoke.
     */
    token: string;
    /**
     * Your integration's unique ID, for authenticating the request.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_id?: string;
    /**
     * Your integration's client secret, for authenticating the request. Begins with `cnvca`.
     *
     * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
     *
     */
    client_secret?: string;
};

/**
 * The [scopes](https://www.canva.dev/docs/connect/appendix/scopes/) that the token has been granted.
 */
export type scope_response = string;

/**
 * Your integration's unique ID, for authenticating the request.
 *
 * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
 *
 */
export type client_id = string;

/**
 * Your integration's client secret, for authenticating the request. Begins with `cnvca`.
 *
 * NOTE: We recommend that you use basic access authentication instead of specifying `client_id` and `client_secret` as body parameters.
 *
 */
export type client_secret = string;

/**
 * Metadata for the Canva Team, consisting of the Team ID,
 * display name, and whether it's an external Canva Team.
 */
export type Team = {
    /**
     * The ID of the Canva Team.
     */
    id: string;
    /**
     * The name of the Canva Team as shown in the Canva UI.
     */
    display_name: string;
    /**
     * Is the user making the API call (the authenticated user) from the Canva Team shown?
     *
     * - When `true`, the user isn't in the Canva Team shown.
     * - When `false`, the user is in the Canva Team shown.
     */
    external: boolean;
};

/**
 * The template object, which contains metadata about the template.
 */
export type Template = {
    /**
     * The template ID.
     */
    id: string;
    /**
     * The template title, as shown in the Canva UI.
     */
    title: string;
    /**
     * A URL Canva users can visit to create a new design from this template.
     */
    url: string;
    /**
     * A list of thumbnail images representing the template. This list contains one thumbnail for each page of the template.
     */
    thumbnails: Array<Thumbnail>;
};

/**
 * A thumbnail image representing the object.
 */
export type Thumbnail = {
    /**
     * The width of the thumbnail image in pixels.
     */
    width: number;
    /**
     * The height of the thumbnail image in pixels.
     */
    height: number;
    /**
     * A URL for retrieving the thumbnail image.
     * This URL expires after 15 minutes. This URL includes a query string
     * that's required for retrieving the thumbnail.
     */
    url: string;
};

/**
 * Metadata for the user, consisting of the User ID and display name.
 */
export type User = {
    /**
     * The ID of the user.
     */
    id: string;
    /**
     * The name of the user as shown in the Canva UI.
     */
    display_name?: string;
};

/**
 * Metadata for the user, consisting of the User ID and Team ID.
 */
export type TeamUserSummary = {
    /**
     * The ID of the user.
     */
    user_id: string;
    /**
     * The ID of the user's Canva Team.
     */
    team_id: string;
};

/**
 * Metadata for the user, consisting of the User ID, Team ID, and display name.
 */
export type TeamUser = {
    /**
     * The ID of the user.
     */
    user_id?: string;
    /**
     * The ID of the user's Canva Team.
     */
    team_id?: string;
    /**
     * The name of the user as shown in the Canva UI.
     */
    display_name?: string;
};

/**
 * Profile for the user, consisting of the display name and other attributes.
 */
export type UserProfile = {
    /**
     * The name of the user as shown in the Canva UI.
     */
    display_name?: string;
};

export type UsersMeResponse = {
    team_user: TeamUserSummary;
};

export type UserProfileResponse = {
    profile: UserProfile;
};

export type Notification = {
    /**
     * The unique identifier for the notification.
     */
    id: string;
    /**
     * When the notification was created, as a UNIX timestamp (in seconds
     * since the UNIX epoch).
     */
    created_at: number;
    content: NotificationContent;
};

/**
 * The notification content object, which contains metadata about the event.
 */
export type NotificationContent = ShareDesignNotificationContent | ShareFolderNotificationContent | CommentNotificationContent | DesignAccessRequestedNotificationContent | DesignApprovalRequestedNotificationContent | DesignApprovalResponseNotificationContent | DesignMentionNotificationContent | TeamInviteNotificationContent | FolderAccessRequestedNotificationContent;

/**
 * The notification content for when someone shares a design.
 */
export type ShareDesignNotificationContent = {
    type: 'share_design';
    triggering_user: User;
    receiving_team_user: TeamUser;
    design: DesignSummary;
    share?: ShareAction;
};

/**
 * The notification content for when someone shares a folder.
 */
export type ShareFolderNotificationContent = {
    type: 'share_folder';
    triggering_user: User;
    receiving_team_user: TeamUser;
    folder: FolderSummary;
    share?: ShareAction;
};

/**
 * The notification content for when someone comments on a design.
 */
export type CommentNotificationContent = {
    type: 'comment';
    triggering_user: User;
    receiving_team_user: TeamUser;
    design: DesignSummary;
    comment: CommentEvent;
};

/**
 * The notification content for when someone requests access to a design.
 */
export type DesignAccessRequestedNotificationContent = {
    type: 'design_access_requested';
    triggering_user: TeamUser;
    receiving_team_user: TeamUser;
    design: DesignSummary;
};

/**
 * The notification content for when someone requests a user to
 * [approve a design](https://www.canva.com/help/get-approval/).
 */
export type DesignApprovalRequestedNotificationContent = {
    type: 'design_approval_requested';
    triggering_user: User;
    receiving_team_user: TeamUser;
    requested_groups: Array<Group>;
    design: DesignSummary;
    approval_request: ApprovalRequestAction;
};

/**
 * The notification content for when someone approves a design or gives feeback.
 */
export type DesignApprovalResponseNotificationContent = {
    type: 'design_approval_response';
    triggering_user: User;
    receiving_team_user: TeamUser;
    requesting_user?: User;
    responding_groups: Array<Group>;
    design: DesignSummary;
    approval_response: ApprovalResponseAction;
};

/**
 * The notification content for when someone mentions a user in a design.
 */
export type DesignMentionNotificationContent = {
    type: 'design_mention';
    triggering_user: User;
    receiving_team_user: TeamUser;
    design: DesignSummary;
};

/**
 * The notification content for when someone is invited to a
 * [Canva team](https://www.canva.com/help/about-canva-for-teams/).
 */
export type TeamInviteNotificationContent = {
    type: 'team_invite';
    triggering_user: User;
    receiving_user: User;
    inviting_team: Team;
};

/**
 * The notification content for when someone requests access to a folder.
 */
export type FolderAccessRequestedNotificationContent = {
    type: 'folder_access_requested';
    triggering_user: TeamUser;
    receiving_team_user: TeamUser;
    folder: Folder;
};

/**
 * Metadata about the share event.
 */
export type ShareAction = {
    /**
     * The optional message users can include when sharing something with another
     * user using the Canva UI.
     */
    message: string;
};

/**
 * Metadata about the design approval request.
 */
export type ApprovalRequestAction = {
    /**
     * The message included by the user when requesting a design approval.
     */
    message: string;
};

/**
 * Metadata about the design approval response.
 */
export type ApprovalResponseAction = {
    /**
     * Whether the design was approved. When `true`, the reviewer has approved
     * the design.
     */
    approved: boolean;
    /**
     * The message included by a user responding to a design approval request.
     */
    message?: string;
};

/**
 * The brand template ID.
 */
export type ParameterbrandTemplateId = string;

/**
 * The `id` of the comment.
 */
export type ParametercommentId = string;

/**
 * The design ID.
 */
export type ParameterdesignId = string;

/**
 * The export job ID.
 */
export type ParameterexportId = string;

/**
 * The folder ID.
 */
export type ParameterfolderIdParameter = string;

export type GetAppJwksData = {
    path: {
        /**
         * The app id
         */
        appId: string;
    };
};

export type GetAppJwksResponse2 = GetAppJwksResponse;

export type GetAppJwksError = unknown;

export type DeleteAssetData = {
    path: {
        /**
         * The ID of the asset.
         */
        assetId: string;
    };
};

export type DeleteAssetResponse = void;

export type DeleteAssetError = unknown;

export type GetAssetData = {
    path: {
        /**
         * The ID of the asset.
         */
        assetId: string;
    };
};

export type GetAssetResponse2 = GetAssetResponse;

export type GetAssetError = unknown;

export type UpdateAssetData = {
    body?: UpdateAssetRequest;
    path: {
        /**
         * The ID of the asset.
         */
        assetId: string;
    };
};

export type UpdateAssetResponse2 = UpdateAssetResponse;

export type UpdateAssetError = unknown;

export type UpdateAssetDeprecatedData = {
    body?: UpdateAssetDeprecatedRequest;
    path: {
        /**
         * The ID of the asset.
         */
        assetId: string;
    };
};

export type UpdateAssetDeprecatedResponse = UpdateAssetResponse;

export type UpdateAssetDeprecatedError = unknown;

export type UploadAssetData = {
    /**
     * Binary of the asset to upload.
     */
    body: (Blob | File);
    headers: {
        'Upload-Metadata': UploadMetadata;
    };
};

export type UploadAssetResponse2 = UploadAssetResponse;

export type UploadAssetError = unknown;

export type CreateAssetUploadJobData = {
    /**
     * Binary of the asset to upload.
     */
    body: (Blob | File);
    headers: {
        'Asset-Upload-Metadata': AssetUploadMetadata;
    };
};

export type CreateAssetUploadJobResponse2 = CreateAssetUploadJobResponse;

export type CreateAssetUploadJobError = unknown;

export type GetAssetUploadJobData = {
    path: {
        /**
         * The asset upload job ID.
         */
        jobId: string;
    };
};

export type GetAssetUploadJobResponse2 = GetAssetUploadJobResponse;

export type GetAssetUploadJobError = unknown;

export type CreateDesignAutofillJobData = {
    body?: CreateDesignAutofillJobRequest;
};

export type CreateDesignAutofillJobResponse2 = CreateDesignAutofillJobResponse;

export type CreateDesignAutofillJobError = unknown;

export type GetDesignAutofillJobData = {
    path: {
        /**
         * The design autofill job ID.
         */
        jobId: string;
    };
};

export type GetDesignAutofillJobResponse2 = GetDesignAutofillJobResponse;

export type GetDesignAutofillJobError = unknown;

export type ListBrandTemplatesData = {
    query?: {
        /**
         * If the success response contains a continuation token, the user has access to more
         * brand templates you can list. You can use this token as a query parameter and retrieve
         * more templates from the list, for example
         * `/v1/brand-templates?continuation={continuation}`.
         * To retrieve all the brand templates available to the user, you might need to make
         * multiple requests.
         */
        continuation?: string;
        /**
         * Filter the brand templates to only show templates created by a particular user.
         * Provide a Canva user ID and it will filter the list to only show brand templates
         * created by that user. The 'owner' of a template is the user who created the design,
         * and the owner can't be changed.
         */
        ownership?: string;
        /**
         * Lets you search the brand templates available to the user using a search term or terms.
         */
        query?: string;
        /**
         * Sort the list of brand templates. This can be one of the following:
         * - `RELEVANCE`: (Default) Sort results using a relevance algorithm.
         * - `MODIFIED_DESCENDING`: Sort results by the date last modified in descending order.
         * - `MODIFIED_ASCENDING`: Sort results by the date last modified in ascending order.
         * - `TITLE_DESCENDING`: Sort results by title in descending order.
         * - `TITLE_ASCENDING`: Sort results by title in ascending order.
         */
        sort_by?: string;
    };
};

export type ListBrandTemplatesResponse2 = ListBrandTemplatesResponse;

export type ListBrandTemplatesError = unknown;

export type GetBrandTemplateData = {
    path: {
        /**
         * The brand template ID.
         */
        brandTemplateId: string;
    };
};

export type GetBrandTemplateResponse2 = GetBrandTemplateResponse;

export type GetBrandTemplateError = unknown;

export type GetBrandTemplateDatasetData = {
    path: {
        /**
         * The brand template ID.
         */
        brandTemplateId: string;
    };
};

export type GetBrandTemplateDatasetResponse2 = GetBrandTemplateDatasetResponse;

export type GetBrandTemplateDatasetError = unknown;

export type CreateCommentData = {
    body: CreateCommentRequest;
};

export type CreateCommentResponse2 = CreateCommentResponse;

export type CreateCommentError = unknown;

export type CreateReplyData = {
    body: CreateReplyRequest;
    path: {
        /**
         * The `id` of the comment.
         */
        commentId: string;
    };
};

export type CreateReplyResponse2 = CreateReplyResponse;

export type CreateReplyError = unknown;

export type GetCommentData = {
    path: {
        /**
         * The `id` of the comment.
         */
        commentId: string;
        /**
         * The design ID.
         */
        designId: string;
    };
};

export type GetCommentResponse2 = GetCommentResponse;

export type GetCommentError = unknown;

export type GetSigningPublicKeysResponse2 = GetSigningPublicKeysResponse;

export type GetSigningPublicKeysError = unknown;

export type ListDesignsData = {
    query?: {
        /**
         * If the success response contains a continuation token, the list contains more designs
         * you can list. You can use this token as a query parameter and retrieve more
         * designs from the list, for example
         * `/v1/designs?continuation={continuation}`.
         *
         * To retrieve all of a user's designs, you might need to make multiple requests.
         */
        continuation?: string;
        /**
         * Filter the list of designs based on the user's ownership of the designs.
         * This can be one of the following:
         *
         * - `owned`: Designs owned by the user.
         * - `shared`: Designs shared with the user.
         * - `any`: Designs owned by and shared with the user.
         */
        ownership?: string;
        /**
         * Lets you search the user's designs, and designs shared with the user, using a search term or terms.
         */
        query?: string;
        /**
         * Sort the list of designs.
         * This can be one of the following:
         *
         * - `relevance`: (Default) Sort results using a relevance algorithm.
         * - `modified_descending`: Sort results by the date last modified in descending order.
         * - `modified_ascending`: Sort results by the date last modified in ascending order.
         * - `title_descending`: Sort results by title in descending order.
         * - `title_ascending`: Sort results by title in ascending order.
         */
        sort_by?: string;
    };
};

export type ListDesignsResponse = GetListDesignResponse;

export type ListDesignsError = unknown;

export type CreateDesignData = {
    body?: CreateDesignRequest;
};

export type CreateDesignResponse2 = CreateDesignResponse;

export type CreateDesignError = unknown;

export type GetDesignData = {
    path: {
        /**
         * The design ID.
         */
        designId: string;
    };
};

export type GetDesignResponse2 = GetDesignResponse;

export type GetDesignError = unknown;

export type CreateDesignImportJobData = {
    /**
     * Binary of the file to import.
     */
    body: (Blob | File);
    headers: {
        'Import-Metadata': DesignImportMetadata;
    };
};

export type CreateDesignImportJobResponse2 = CreateDesignImportJobResponse;

export type CreateDesignImportJobError = unknown;

export type GetDesignImportJobData = {
    path: {
        /**
         * The design import job ID.
         */
        jobId: string;
    };
};

export type GetDesignImportJobResponse2 = GetDesignImportJobResponse;

export type GetDesignImportJobError = unknown;

export type CreateDesignExportJobData = {
    body?: CreateDesignExportJobRequest;
};

export type CreateDesignExportJobResponse2 = CreateDesignExportJobResponse;

export type CreateDesignExportJobError = unknown;

export type GetDesignExportJobData = {
    path: {
        /**
         * The export job ID.
         */
        exportId: string;
    };
};

export type GetDesignExportJobResponse2 = GetDesignExportJobResponse;

export type GetDesignExportJobError = unknown;

export type DeleteFolderData = {
    path: {
        /**
         * The folder ID.
         */
        folderId: string;
    };
};

export type DeleteFolderResponse = void;

export type DeleteFolderError = unknown;

export type GetFolderData = {
    path: {
        /**
         * The folder ID.
         */
        folderId: string;
    };
};

export type GetFolderResponse2 = GetFolderResponse;

export type GetFolderError = unknown;

export type UpdateFolderData = {
    body: UpdateFolderRequest;
    path: {
        /**
         * The folder ID.
         */
        folderId: string;
    };
};

export type UpdateFolderResponse2 = UpdateFolderResponse;

export type UpdateFolderError = unknown;

export type ListFolderItemsData = {
    path: {
        /**
         * The folder ID.
         */
        folderId: string;
    };
    query?: {
        /**
         * If the success response contains a continuation token, the folder contains more items
         * you can list. You can use this token as a query parameter and retrieve more
         * items from the list, for example
         * `/v1/folders/{folderId}/items?continuation={continuation}`.
         *
         * To retrieve all the items in a folder, you might need to make multiple requests.
         */
        continuation?: string;
        /**
         * Filter the folder items to only return specified types. The available types are:
         * `asset`, `design`, `folder`, and `template`. To filter for more than one item type,
         * provide a comma-delimited list.
         */
        item_types?: string;
    };
};

export type ListFolderItemsResponse2 = ListFolderItemsResponse;

export type ListFolderItemsError = unknown;

export type MoveFolderItemData = {
    body?: MoveFolderItemRequest;
};

export type MoveFolderItemResponse = void;

export type MoveFolderItemError = unknown;

export type CreateFolderData = {
    body: CreateFolderRequest;
};

export type CreateFolderResponse2 = CreateFolderResponse;

export type CreateFolderError = unknown;

export type ExchangeAccessTokenData = unknown;

export type ExchangeAccessTokenResponse2 = ExchangeAccessTokenResponse;

export type ExchangeAccessTokenError = unknown;

export type IntrospectTokenData = unknown;

export type IntrospectTokenResponse2 = IntrospectTokenResponse;

export type IntrospectTokenError = unknown;

export type RevokeTokensData = unknown;

export type RevokeTokensResponse = void;

export type RevokeTokensError = unknown;

export type UsersMeResponse2 = UsersMeResponse;

export type UsersMeError = unknown;

export type GetUserProfileResponse = UserProfileResponse;

export type GetUserProfileError = unknown;

export type $OpenApiTs = {
    '/v1/apps/{appId}/jwks': {
        get: {
            req: GetAppJwksData;
            res: {
                /**
                 * OK
                 */
                '200': GetAppJwksResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/assets/{assetId}': {
        delete: {
            req: DeleteAssetData;
            res: {
                /**
                 * OK
                 */
                '204': void;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        get: {
            req: GetAssetData;
            res: {
                /**
                 * OK
                 */
                '200': GetAssetResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        patch: {
            req: UpdateAssetData;
            res: {
                /**
                 * OK
                 */
                '200': UpdateAssetResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        post: {
            req: UpdateAssetDeprecatedData;
            res: {
                /**
                 * OK
                 */
                '200': UpdateAssetResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/assets/upload': {
        post: {
            req: UploadAssetData;
            res: {
                /**
                 * OK
                 */
                '200': UploadAssetResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/asset-uploads': {
        post: {
            req: CreateAssetUploadJobData;
            res: {
                /**
                 * OK
                 */
                '200': CreateAssetUploadJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/asset-uploads/{jobId}': {
        get: {
            req: GetAssetUploadJobData;
            res: {
                /**
                 * OK
                 */
                '200': GetAssetUploadJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/autofills': {
        post: {
            req: CreateDesignAutofillJobData;
            res: {
                /**
                 * OK
                 */
                '200': CreateDesignAutofillJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/autofills/{jobId}': {
        get: {
            req: GetDesignAutofillJobData;
            res: {
                /**
                 * OK
                 */
                '200': GetDesignAutofillJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/brand-templates': {
        get: {
            req: ListBrandTemplatesData;
            res: {
                /**
                 * OK
                 */
                '200': ListBrandTemplatesResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/brand-templates/{brandTemplateId}': {
        get: {
            req: GetBrandTemplateData;
            res: {
                /**
                 * OK
                 */
                '200': GetBrandTemplateResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/brand-templates/{brandTemplateId}/dataset': {
        get: {
            req: GetBrandTemplateDatasetData;
            res: {
                /**
                 * OK
                 */
                '200': GetBrandTemplateDatasetResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/comments': {
        post: {
            req: CreateCommentData;
            res: {
                /**
                 * OK
                 */
                '200': CreateCommentResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/comments/{commentId}/replies': {
        post: {
            req: CreateReplyData;
            res: {
                /**
                 * OK
                 */
                '200': CreateReplyResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/designs/{designId}/comments/{commentId}': {
        get: {
            req: GetCommentData;
            res: {
                /**
                 * OK
                 */
                '200': GetCommentResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/connect/keys': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': GetSigningPublicKeysResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/designs': {
        get: {
            req: ListDesignsData;
            res: {
                /**
                 * OK
                 */
                '200': GetListDesignResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        post: {
            req: CreateDesignData;
            res: {
                /**
                 * OK
                 */
                '200': CreateDesignResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/designs/{designId}': {
        get: {
            req: GetDesignData;
            res: {
                /**
                 * OK
                 */
                '200': GetDesignResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/imports': {
        post: {
            req: CreateDesignImportJobData;
            res: {
                /**
                 * OK
                 */
                '200': CreateDesignImportJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/imports/{jobId}': {
        get: {
            req: GetDesignImportJobData;
            res: {
                /**
                 * OK
                 */
                '200': GetDesignImportJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/exports': {
        post: {
            req: CreateDesignExportJobData;
            res: {
                /**
                 * OK
                 */
                '200': CreateDesignExportJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/exports/{exportId}': {
        get: {
            req: GetDesignExportJobData;
            res: {
                /**
                 * OK
                 */
                '200': GetDesignExportJobResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/folders/{folderId}': {
        delete: {
            req: DeleteFolderData;
            res: {
                /**
                 * OK
                 */
                '204': void;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        get: {
            req: GetFolderData;
            res: {
                /**
                 * OK
                 */
                '200': GetFolderResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
        patch: {
            req: UpdateFolderData;
            res: {
                /**
                 * OK
                 */
                '200': UpdateFolderResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/folders/{folderId}/items': {
        get: {
            req: ListFolderItemsData;
            res: {
                /**
                 * OK
                 */
                '200': ListFolderItemsResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/folders/move': {
        post: {
            req: MoveFolderItemData;
            res: {
                /**
                 * OK
                 */
                '204': void;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/folders': {
        post: {
            req: CreateFolderData;
            res: {
                /**
                 * OK
                 */
                '200': CreateFolderResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/oauth/token': {
        post: {
            req: ExchangeAccessTokenData;
            res: {
                /**
                 * OK
                 */
                '200': ExchangeAccessTokenResponse;
                /**
                 * Error Response
                 */
                default: OauthError;
            };
        };
    };
    '/v1/oauth/introspect': {
        post: {
            req: IntrospectTokenData;
            res: {
                /**
                 * OK
                 */
                '200': IntrospectTokenResponse;
                /**
                 * Error Response
                 */
                default: OauthError;
            };
        };
    };
    '/v1/oauth/revoke': {
        post: {
            req: RevokeTokensData;
            res: {
                /**
                 * OK
                 */
                '204': void;
                /**
                 * Error Response
                 */
                default: OauthError;
            };
        };
    };
    '/v1/users/me': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': UsersMeResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
    '/v1/users/me/profile': {
        get: {
            res: {
                /**
                 * OK
                 */
                '200': UserProfileResponse;
                /**
                 * Error Response
                 */
                default: Error;
            };
        };
    };
};